name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (optional, defaults to latest tag)'
        required: false
        type: string

env:
  JAVA_VERSION: '21'
  MAVEN_VERSION: '3.9.9'
  DOCKER_REGISTRY: 'gcr.io'
  IMAGE_NAME: 'auth-service'
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

jobs:
  # Quality Assurance
  quality-assurance:
    name: Quality Assurance
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: 'maven'
        
    - name: Cache Maven packages
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
        
    # Quick Quality Checks
    - name: Quick Quality Checks
      run: |
        echo "ğŸ” Running quick quality checks..."
        mvn clean compile test \
          -Dmaven.test.failure.ignore=false \
          -Djacoco.skip=false
        
        mvn spotless:check \
          -Dspotless.check.skip=false
        
    # Upload Quality Reports
    - name: Upload Quality Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: quality-reports-${{ github.run_number }}
        path: |
          **/target/dependency-check-report.json
        retention-days: 30

  # Build and Package
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: quality-assurance
    if: needs.quality-assurance.result == 'success'
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-tag-date: ${{ steps.build.outputs.image-tag-date }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: 'maven'
        
    - name: Calculate Version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "push" ]]; then
          # Extract version from tag (remove 'v' prefix)
          VERSION=${GITHUB_REF#refs/tags/}
          VERSION=${VERSION#v}  # Remove 'v' prefix if present
        else
          # Manual dispatch - use provided version or latest tag
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Get latest tag
            VERSION=$(git describe --tags --abbrev=0 | sed 's/^v//')
          fi
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "ğŸ“¦ Version: $VERSION"
        
    - name: Set up Docker Build
      uses: docker/setup-buildx-action@v3
      
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Configure Docker for GCR
      run: |
        gcloud auth configure-docker gcr.io --quiet
        
    - name: Build and Push to GCR
      id: build
      run: |
        echo "ğŸ—ï¸ Building application..."
        mvn clean package -DskipTests
        
        # Create GCR image tags
        TAG_DATE=$(date +%Y%m%d%H%M%S)
        REGISTRY="${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}"
        IMAGE_TAG="$REGISTRY/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
        IMAGE_TAG_DATE="$REGISTRY/${{ env.IMAGE_NAME }}:$TAG_DATE"
        
        echo "ğŸ³ Building Docker image..."
        docker buildx build --platform linux/amd64 \
          --build-arg GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }} \
          --build-arg GITHUB_USERNAME=${{ github.actor }} \
          -f auth-service/Dockerfile.prod \
          -t $IMAGE_TAG \
          -t $IMAGE_TAG_DATE \
          auth-service/ --push
        
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "image-tag-date=$IMAGE_TAG_DATE" >> $GITHUB_OUTPUT
        echo "ğŸ³ Image tags: $IMAGE_TAG, $IMAGE_TAG_DATE"
        
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts-${{ github.run_number }}
        path: |
          **/target/*.jar
          **/target/classes/
        retention-days: 30
        
    - name: Create Build Summary
      run: |
        echo "ğŸ“‹ Build Summary" > build-summary.txt
        echo "Version: ${{ steps.version.outputs.version }}" >> build-summary.txt
        echo "Image Tag: ${{ steps.build.outputs.image-tag }}" >> build-summary.txt
        echo "Image Tag Date: ${{ steps.build.outputs.image-tag-date }}" >> build-summary.txt
        echo "Registry: ${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}" >> build-summary.txt
        echo "Build Date: $(date)" >> build-summary.txt
        
    - name: Upload Build Summary
      uses: actions/upload-artifact@v4
      with:
        name: build-summary-${{ github.run_number }}
        path: build-summary.txt
        retention-days: 30

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quality-assurance, build]
    if: needs.quality-assurance.result == 'success' && needs.build.result == 'success'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Build Artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts-${{ github.run_number }}
        path: artifacts/
        
    - name: Download Build Summary
      uses: actions/download-artifact@v4
      with:
        name: build-summary-${{ github.run_number }}
        path: ./
        
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Configure kubectl
      run: |
        # Install gke-gcloud-auth-plugin using apt-get
        if ! command -v gke-gcloud-auth-plugin &> /dev/null; then
          echo "Installing gke-gcloud-auth-plugin..."
          sudo apt-get update
          sudo apt-get install -y google-cloud-cli-gke-gcloud-auth-plugin
        fi
        
        # Configure kubectl to use the plugin
        gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} \
          --region ${{ secrets.GKE_REGION }} \
          --project ${{ secrets.GCP_PROJECT_ID }}
        
        # Set the USE_GKE_GCLOUD_AUTH_PLUGIN environment variable
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
        
    - name: Deploy to Production Environment
      run: |
        echo "ğŸ” Deploying auth-service to production environment..."
        
        # Configuration
        PROJECT_ID="${{ env.PROJECT_ID }}"
        CLUSTER_NAME="${{ secrets.GKE_CLUSTER_NAME }}"
        NAMESPACE="${{ secrets.K8S_NAMESPACE || 'microservices' }}"
        VERSION="${{ needs.build.outputs.version }}"
        IMAGE_TAG="${{ needs.build.outputs.image-tag }}"
        
        echo "ğŸ“‹ Production Deployment Plan:"
        echo "- Environment: Production"
        echo "- Application: Auth Service"
        echo "- Version: $VERSION"
        echo "- Image: $IMAGE_TAG"
        echo "- Project ID: $PROJECT_ID"
        echo "- Cluster: $CLUSTER_NAME"
        echo "- Namespace: $NAMESPACE"
        
        # Check if cluster exists and get credentials
        echo "ğŸ” Checking cluster access..."
        if ! gcloud container clusters describe $CLUSTER_NAME --zone=${{ secrets.GKE_REGION }} > /dev/null 2>&1; then
            echo "âŒ Cluster $CLUSTER_NAME not found in ${{ secrets.GKE_REGION }}"
            exit 1
        fi
        
        # Get cluster credentials
        echo "ğŸ” Getting cluster credentials..."
        gcloud container clusters get-credentials $CLUSTER_NAME --zone=${{ secrets.GKE_REGION }}
        
        # Deploy namespace
        echo "ğŸ“ Creating namespace..."
        kubectl apply -f k8s/namespace.yaml
        
        # Deploy ConfigMap and Secrets
        echo "âš™ï¸  Deploying ConfigMap and Secrets..."
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secrets.yaml
        
        # Deploy auth-service with version substitution
        echo "ğŸ” Deploying auth-service..."
        export IMAGE_VERSION=$VERSION
        export IMAGE_TAG=$IMAGE_TAG
        
        # Create temporary auth-service.yaml with image substitution
        cat k8s/services/auth-service.yaml | envsubst | kubectl apply -f -
        
        # Wait for auth-service to be ready
        echo "â³ Waiting for auth-service to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/auth-service -n $NAMESPACE
        
        # Verify deployment
        echo "âœ… Verifying deployment..."
        kubectl get pods -n $NAMESPACE
        kubectl get services -n $NAMESPACE
        
        echo "âœ… Auth-service deployment completed successfully!"
        
    - name: Run Production Tests
      run: |
        echo "ğŸ§ª Running production tests..."
        
        NAMESPACE="${{ secrets.K8S_NAMESPACE || 'microservices' }}"
        
        # Get service information
        echo "ğŸ“‹ Service Information:"
        kubectl get service auth-service -n $NAMESPACE
        
        # Get pod status
        echo "ğŸ“Š Pod Status:"
        kubectl get pods -n $NAMESPACE -l app=auth-service
        
        # Check service endpoints
        echo "ğŸ” Checking service endpoints..."
        kubectl get endpoints auth-service -n $NAMESPACE
        
        # Health check using the correct endpoint
        echo "ğŸ¥ Running health checks..."
        echo "Testing health endpoint: https://api.posadskiy.com/auth/health"
        curl -f https://api.posadskiy.com/auth/health || echo "Health check failed"
        
        # Additional internal health check for debugging
        echo "ğŸ” Testing internal health endpoint..."
        kubectl run test-pod --image=curlimages/curl --rm -it --restart=Never -- \
            curl -f http://auth-service:8080/actuator/health || echo "Internal health check failed"
        
        echo "âœ… Production tests completed"
        
    - name: Create Release
      uses: actions/github-script@v7
      if: github.event_name == 'push'  # Only create release on tag push
      with:
        script: |
          const version = '${{ needs.build.outputs.version }}';
          const releaseNotes = `
          ## ğŸš€ Production Release ${version}
          
          ### ğŸ“¦ What's New
          - Deployed to production environment
          - All quality checks passed
          - Built and pushed to Google Container Registry (GCR)
          - Deployed to GKE cluster: ${{ secrets.GKE_CLUSTER_NAME }}
          - Namespace: ${{ secrets.K8S_NAMESPACE || 'microservices' }}
          
          ### ğŸ”— Links
          - [Production Environment](https://api.posadskiy.com/auth)
          - [Health Check](https://api.posadskiy.com/auth/health)
          - [API Documentation](https://api.posadskiy.com/auth/swagger-ui)
          - [GCR Registry](https://console.cloud.google.com/gcr/images/${{ env.PROJECT_ID }})
          
          ### ğŸ“Š Metrics
          - Build Time: ${process.env.GITHUB_JOB} minutes
          - Test Coverage: Available in artifacts
          - Security Scan: Passed
          - Container Registry: Google Container Registry (GCR)
          
          ---
          *Released by GitHub Actions*`;
          
          github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${version}`,
            name: `Release ${version}`,
            body: releaseNotes,
            draft: false,
            prerelease: false
          });
        
    - name: Notify Production Deployment
      uses: actions/github-script@v7
      with:
        script: |
          const deploymentType = '${{ github.event_name }}' === 'push' ? 'Tag Push' : 'Manual';
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## ğŸ‰ Production Deployment Complete
          
          **Environment**: Production
          **Version**: ${{ needs.build.outputs.version }}
          **Image**: ${{ needs.build.outputs.image-tag }}
          **Image Date Tag**: ${{ needs.build.outputs.image-tag-date }}
          **Registry**: ${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}
          **Cluster**: ${{ secrets.GKE_CLUSTER_NAME }}
          **Namespace**: ${{ secrets.K8S_NAMESPACE || 'microservices' }}
          **Commit**: ${{ github.sha }}
          **Trigger**: ${deploymentType}
          
          ### ğŸ”— Links
          - [Production Environment](https://api.posadskiy.com/auth)
          - [Health Check](https://api.posadskiy.com/auth/health)
          - [Release Notes](https://github.com/${{ github.repository }}/releases/tag/v${{ needs.build.outputs.version }})
          - [GCR Registry](https://console.cloud.google.com/gcr/images/${{ env.PROJECT_ID }})
          
          ---
          *Deployed by GitHub Actions*`
          });

  # Monitoring and Alerting
  monitor:
    name: Monitor Deployment
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Configure kubectl
      run: |
        # Install gke-gcloud-auth-plugin using apt-get
        if ! command -v gke-gcloud-auth-plugin &> /dev/null; then
          echo "Installing gke-gcloud-auth-plugin..."
          sudo apt-get update
          sudo apt-get install -y google-cloud-cli-gke-gcloud-auth-plugin
        fi
        
        # Configure kubectl to use the plugin
        gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} \
          --region ${{ secrets.GKE_REGION }} \
          --project ${{ secrets.GCP_PROJECT_ID }}
        
        # Set the USE_GKE_GCLOUD_AUTH_PLUGIN environment variable
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
        
    - name: Monitor Application Health
      run: |
        echo "ğŸ“Š Monitoring application health..."
        
        NAMESPACE="${{ secrets.K8S_NAMESPACE || 'microservices' }}"
        
        # Check if kubectl is working
        echo "ğŸ” Testing kubectl connection..."
        kubectl cluster-info || {
            echo "âŒ kubectl connection failed"
            echo "ğŸ’¡ This might be due to cluster access issues or authentication problems"
            exit 1
        }
        
        # Get pod status and resource usage
        echo "ğŸ“Š Pod Status and Resource Usage:"
        kubectl get pods -n $NAMESPACE -l app=auth-service || echo "No auth-service pods found"
        kubectl top pods -n $NAMESPACE -l app=auth-service || echo "Resource usage not available"
        
        # Get service status
        echo "ğŸŒ Service Status:"
        kubectl get services -n $NAMESPACE -l app=auth-service || echo "No auth-service services found"
        
        # Get deployment status
        echo "ğŸš€ Deployment Status:"
        kubectl get deployments -n $NAMESPACE -l app=auth-service || echo "No auth-service deployments found"
        
        # Check logs for any errors
        echo "ğŸ“ Recent Logs:"
        kubectl logs --tail=50 -n $NAMESPACE -l app=auth-service || echo "No logs available"
        
        # External health check
        echo "ğŸ¥ External Health Check:"
        curl -f https://api.posadskiy.com/auth/health || echo "External health check failed"
        
        # Metrics collection from external endpoint
        echo "ğŸ“ˆ Metrics Collection:"
        curl -s https://api.posadskiy.com/auth/actuator/metrics || echo "Metrics endpoint not accessible"
        curl -s https://api.posadskiy.com/auth/actuator/prometheus || echo "Prometheus endpoint not accessible"
        
        echo "âœ… Monitoring completed"
        
    - name: Send Notifications
      run: |
        echo "ğŸ“¢ Sending notifications..."
        
        # Mock notification commands
        echo "slack-notify --channel #deployments --message 'Production deployment completed'"
        echo "email-notify --to team@example.com --subject 'Production Deployment Status'"
        
        echo "âœ… Notifications sent" 
